import { ItemType, Action, Bonus, Synergy, Deployable, Counter } from "@/class";
import { ICounterData, IActionData, IDeployableData, IBonusData, ISynergyData } from "@/interface";
import _ from "lodash";
import { store } from "@/hooks";
import { ITagData } from './GeneralInterfaces';
import { Tag } from './Tag';
import { DamageType } from './enums';

// items that are stored as compendium data, refernced by ID and contain
// at minimum a name, itemtype, and brew

export const CORE_BREW_ID = "Core";
type Constructor = new (...args: any[]) => {};

// Simplifies serialization implementation to be more generally consistent
abstract class Mixin<T> {
    constructor(){}

    public abstract load(data: T): void;
    public abstract save(): T;
}

// Represents something that is stored / searchable in the compendium
export interface ICompendiumItemData {
    id: string;
    name: string;
    description: string;
    brew: string; // Homebrew pack it came from
}

// Represents something tied to a license
export interface ILicensed {
  source: string, // Manufacturer ID
  license: string, // Frame Name
  license_level: number, // set to 0 to be available to all Pilots
}

export class MixLicensed extends Mixin<ILicensed> {
    private _source: string = "";
    private _license: string = "";
    private _license_level: number = 0; 
    public get Source(): string { return this._source; }
    public get License(): string { return this._license; }
    public get LicenseLevel(): number { return this._license_level; }

    public load(data: ILicensed) {
        this._source = data.source;
        this._license = data.license;
        this._license_level = data.license_level;
    }

    public save(): ILicensed {
        return {
            license: this.License,
            license_level: this.LicenseLevel,
            source: this.Source
        }
    }
}

// For items that have actions/effects/synergies. May be better to separate these...........
export interface IHasActions {
  actions?: IActionData[] | null,
}

export interface IHasBonuses {
  bonuses?: IBonusData[] | null,
}
export interface IHasSynergies {
  synergies?: ISynergyData[] | null,
}

export class MixActions extends Mixin<IHasActions> {
    private _actions: Action[] = [];
    public get Actions(): Action[] { return [...this._actions]; }

    public load(data: IHasActions) {
        this._actions = data.actions?.map(a => new Action(a)) || [];
    }

    public save(): IHasActions {
        return {
            actions: this._actions.map(a => a.Serialize()),
        }
    }
}


export class MixBonuses extends Mixin<IHasBonuses> {
    private _bonuses: Bonus[] = [];
    public get Bonuses(): Bonus[] { return [...this._bonuses] };

    public load(data: IHasBonuses) {
        this._bonuses = data.bonuses?.map(a => new Bonus(a)) || [];
    }

    public save(): IHasBonuses {
        return {
            bonuses: this._bonuses.map(b => b.Serialize()),
        }
    }
}

export class MixSynergies extends Mixin<IHasSynergies> {
    private _synergies: Synergy[] = [];
    public get Synergies(): Synergy[] { return [...this._synergies]; }

    public load(data: IHasSynergies) {
        this._synergies = data.synergies?.map(a => new Synergy(a)) || [];
    }

    public save(): IHasSynergies {
        return {
            synergies: this._synergies.map(s => s.Serialize()),
        }
    }
}


// For items that have deployables
export interface IHasDeployables {
  deployables?: IDeployableData[] | null,
}



export class MixDeployables extends Mixin<IHasDeployables> {
    private _deployables: Deployable[] = [];
    public get Deployables(): Deployable[] { return [...this._deployables]; }

    public load(data: IHasDeployables) {
        this._deployables = data.deployables?.map(a => new Deployable(a)) || [];
    }

    public save(): IHasDeployables {
        return {
            deployables: this._deployables.map(d => d.Serialize())
        }
    }
}


// If it has integrated items (a list of IDs of systems/weapons that should be included with this item. Be wary of cyclic data)
export interface IHasIntegrated {
  integrated?: string[] | null
}

export class MixIntegrated extends Mixin<IHasIntegrated> {
    private _integrated: string[] = [];
    public get Integrated(): string[] { return [...this._integrated]; }

    public load(data: IHasIntegrated) {
        this._integrated = data.integrated || [];
    }

    public save(): IHasIntegrated {
        return {
            integrated: [...this.integrated]
        }
    }
}

// Item can have tags
export interface IHasTags {
  tags?: ITagData[] | null
}

export class MixTags extends Mixin<IHasTags> {
    private _tags: Tag[] = [];
    public get Tags(): Tag[] { return [...this._tags]; }

    public load(data: IHasTags) {
        this._tags = Tag.Deserialize(data.tags || []);
    }

    public save(): IHasTags {
        return {
            tags: this.tags.map(t => t.SerializeInstance())
        }
    }
}

// Item can have counters
export interface IHasCounters {
  counters?: ICounterData[] | null
}

export class MixCounters extends Mixin<IHasCounters> {
    private _counters: Counter[] = [];
    public get Counters(): Counter[] { return ...this._counters; }

    public load(data: IHasCounters ) {
        this._counters = data.counters?.map(c => new Counter(c)) || [];
    }

    public save(): IHasCounters {
        return {
            counters: this._counters.map(c => c.Serialize())
        }
    }
}

// Include for flavored items
export interface IHasFlavor {
    flavorName?: string | null;
    flavorDescription?: string | null;
}

export class MixFlavor extends Mixin<IHasFlavor> {
    private _flavor_name: string | null = null;
    private _flavor_description: string | null = null;
    public get FlavorName(): string | null { return this._flavor_name; }
    public get FlavorDescription(): string | null { return this._flavor_description; }

    public load(data: IHasFlavor) {
        this._flavor_name = data.flavorDescription || null;
        this._flavor_name = data.flavorName || null;
    }

    public save(): IHasFlavor {
        return {
            flavorDescription: this.FlavorDescription,
            flavorName: this.FlavorName
        }
    }
}

// Include user data, e.g. notes, damage types
export interface IUserNoted {
    note?: string | null;
    customDamageType?: DamageType | null;
}

export class MixUserNoted extends Mixin<IUserNoted> {
    public get Note(): string | null { return this._note; }
    public get CustomDamageType(): DamageType | null { return this._custom_damage_type; }
    private _custom_damage_type: DamageType | null = null
    private _note: string | null = null

    public load(data: IUserNoted) {
        this._note = data.note || null;
        this._custom_damage_type = data.customDamageType || null;
    }

    public save(): IUserNoted {
        return {
            customDamageType: this.CustomDamageType,
            note: this.Note
        }
    }
}

function Scale<TBase extends Constructor>(Base: TBase) {
  return class Scaling extends Base {
    // Mixins may not declare private/protected properties
    // however, you can use ES2020 private fields
    _scale = 1;

    setScale(scale: number) {
      this._scale = scale;
    }

    get scale(): number {
      return this._scale;
    }
  };
}

// A somewhat unweildy super-meta class
// TODO: add save callbacks to mixins...
export abstract class CompendiumItem<D, M> {
    private _id: string;
    protected _name: string;
    protected _description: string;
    protected _item_type: ItemType;
    protected _brew: string;


    public constructor(type: ItemType, data: D & ICompendiumItemData, ...md: Array<new (x:D) => M>) {
        this._id = data.id;
        this._name = data.name;
        this._brew = data.brew;
        this._description = data.description;
        this._item_type = type;
    } 


    /*
    public constructor(itemData?: ICompendiumItemData | null) {
        if (itemData) {
            this._id = itemData.id;
            this._name = itemData.name;
            this._description = itemData.description;
            this._item_type = ItemType.None;
            this._brew = itemData.brew || CORE_BREW_ID;
        } else {
            this._id = this._name = this._description = this._note = this._brew = "";
            this._item_type = ItemType.None;
            this.Counters = [];
            this._err = "Item data not found!";
        }
    }
    */

    abstract protected save(): void;

    public get ID(): string {
        return this._id;
    }

    public get Name(): string {
        return this._name;
    }

    public set Name(val: string) {
        this._name = val;
        this.save();
    }

    public get Description(): string {
        return this._description;
    }

    public set Description(val: string) {
        this._description = val;
        this.save();
    }

    public get ItemType(): ItemType {
        return this._item_type;
    }

    public get Brew(): string {
        return this._brew;
    }

    public get Icon(): string {
        return "cci-" + _.kebabCase(this.ItemType);
    }

    public get Color(): string {
        return _.kebabCase(this.ItemType);
    }
}